---
title: "Functional Simulation"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r warning=FALSE, message=FALSE}
library(Matrix)
library(MASS)
library(fda)
library(lme4)
library(pedigreemm)
library(mvnfast)
library(ggplot2)
library(plotly)
```

## Functional Mixed-Effect Model

$$ \bf{Y} = \bf{Z^G \alpha} + \bf{Z^E \gamma} + \bf{\epsilon}$$ with the following distribution of the random vectors: \begin{align*}
\alpha &\sim N(\bf{0}, \bf{A \otimes C^G})\\

\gamma &\sim N(\bf{0}, \bf{I_N \otimes C^G})\\
\epsilon & \sim N(\bf{0}, \sigma^2_{res} *\bf{I_n})
\end{align*} assuming there are $N$ individuals and total $n$ measurements.

For the simulation study, we will fix a basis $\phi(t)$ for our functional space and true covariance matrices $\bf{C^G}$ and $\bf{C^E}$. Therefore the true genetic and environmental covariance functions which will be estimated are:
\begin{align*}
G(t,s) & = \phi(t)^T \ast \bf{C^G} \ast \phi(t)\\
E(t,s) & = \phi(t)^T \ast \bf{C^E} \ast \phi(t)
\end{align*}
Then we will generate a set of responses and fit the mixed-effect model to get the estimated covariance functions, which then will be compared with the true ones.

## Simulation process

Step 1: Fix functional basis, covariance matrices and residual variance. Here we will use 3 B-spline basis.
```{r}
### use b-spline basis
basisObj <- create.bspline.basis(c(0,1), nbasis = 3, norder = 3)
### genetic covariance matrix
C_gen <-  matrix(c(400, 40, 0,
                   40, 200, 40,
                   0, 40, 200), nrow = 3, byrow = T)
### environmental covariance matrix
C_env <- matrix(c(400, 40, 0,
                  40, 200, 40,
                  0, 40, 200), nrow = 3, byrow = T)
### residual variance
sigma2 <- 50
```

```{r echo=FALSE}
## Plot the true covariances functions
time_rang <- seq(0,1,length=10)
basis <- eval.basis(time_rang, basisObj) 
C_gen_fun <- basis %*% C_gen %*% t(basis)
C_env_fun <- basis %*% C_env %*% t(basis)
P_true <- C_gen_fun + C_env_fun

fit4 <- plot_ly(x = time_rang, y = time_rang, z = ~C_gen_fun,
                type = 'surface', showscale = FALSE) %>% 
  layout(title = "TRUE Gen Variance", 
               scene = list(zaxis = list(title=""),
                            xaxis = list(title = "time"),
                            yaxis = list(title = "time")))
fit5 <- plot_ly(x = time_rang, y = time_rang, z = ~C_env_fun,
                type = 'surface', showscale = FALSE) %>% 
  layout(title = "TRUE Env Variance", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))
fit6 <- plot_ly(x = time_rang, y = time_rang, z = ~P_true,
                type = 'surface', showscale = FALSE) %>% 
  layout(title = "TRUE Phen Variance", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))

fit4
fit5
fit6
```

Step 2: Set the distribution of the random effect vectors $\bf{\alpha}$ and $\bf{\gamma}$.
Remark: we will assume in total there are 873 individuals so the same genetic relationship matrix $A$ computed in developing our mixed-effect model will be used in our simulation study. For now, assume each individual has 10 regular sampling points from the unit interval. Later we will change the number of observations per individual to see how this will affect the covariance estimation.
```{r include =FALSE}
### Calculate the genetic relationship matrix A (use the TC dataset)
setwd("D:/KCL_2023-2027_PhD/Year 1/Genetics/FMEMs-quantitative-genetics/R_code")
TRFUN25PUP4 = read.delim("TRFUN25PUP4.DAT",header = FALSE)
names(TRFUN25PUP4)<-c("id","sire","dam","trait","x")
df <- data.frame(TRFUN25PUP4)

FirstUniqueIdPos <- which(duplicated(df$id) == FALSE)
N = length(FirstUniqueIdPos) # N = 873 subjects
n = 8730 # each individual have 10 observations, in total 8730

pos = df$id[FirstUniqueIdPos] # extract ids for all subjects
sire_id = df$sire[FirstUniqueIdPos] # extract ids for sire
dam_id = df$dam[FirstUniqueIdPos] # extract ids for dam

pede <- editPed(sire = sire_id, dam = dam_id, label = pos)
ped<- with(pede, pedigree(label=label, sire=sire, dam=dam))
A <- getA(ped)[163:1035,163:1035]
```

```{r}
### reparameterised genetic covariance 
C_gen_para <- as(kronecker(A, C_gen), "dgCMatrix") 

### reparameterised environmental covariance 
I_N <- as(diag(873), "dgCMatrix")
C_env_para <- as(kronecker(I_N, C_env), "dgCMatrix")

### distribution of the genetic random vector
mu <- rep(0, dim(C_gen_para)[1])
alpha <- rmvn(n=50, mu = mu, sigma = C_gen_para) # here we generate 50 random vectors from multivariate normal distribution
gamma <- rmvn(n=50, mu = mu, sigma = C_env_para)

### distribution of the error vector
mu_res <- rep(0, 8730)
I_n <- as(diag(8730), "dgCMatrix")
res_cov <- as(sigma2 * I_n, "dgCMatrix") 
  
res <- rmvn(n=50, mu=mu_res, sigma = res_cov) # error vector
```

Step 3: Use the modular functions of `lme4()` to compute the random effect design matrices.  
```{r}
uniqueIds <- seq(1,873, length=873)
id <- rep(uniqueIds, each=10)
time_rang <- seq(0,1,length=10) # 10 time points
basis <- eval.basis(time_rang, basisObj) # basis function evaluated at these time points
b1 <- rep(basis[,1], times = 873)
b2 <- rep(basis[,2], times = 873)
b3 <- rep(basis[,3], times = 873)

y_pre <- rep(1, 8730) # dummy response values, will be updated 
df_pre <- data.frame(id = id, y_pre = y_pre, b1 = b1, b2 = b2, b3 = b3)

### mixed-effect formula
parsedFormula <- y_pre ~ (-1 + df_pre$b1 + df_pre$b2 + df_pre$b3 | df_pre$id) + 
  (-1 + df_pre$b1 + df_pre$b2 + df_pre$b3 | df_pre$id)

Z_pre <- t(lFormula(formula=parsedFormula, data=df_pre)$reTrms$Zt) ### random effect design matrix

### update the genetic covariance matrix
L <- as(t(chol(A)), "dgCMatrix")
I3 <- as(diag(3), "dgCMatrix")
M <- kronecker(L, I3)
ZE <- Z_pre[,1:2619] 
ZG <- Z_pre[,1:2619] %*% M 

### random effects + residual
df_pre$y_pre <- as.vector(ZG %*% alpha[1,] + ZE %*% gamma[1,] + res[1,]) # here just use the first simulated alpha and gamma
```

Step 4: Use `lm()` to calculate the fixed-effect. 
```{r}
f <- lm(y_pre ~ -1 + df_pre$b1 + df_pre$b2 + df_pre$b3, data = df_pre)
fix_ef <- f$coefficients[1] * df_pre$b1 + f$coefficients[2] * df_pre$b2 + f$coefficients[3] * df_pre$b3 ### fixed-effect 
```

Step 5: Generate response and reform into a dataframe for model-fitting.
```{r}
response <- as.vector(fix_ef + df_pre$y_pre) 
df_simu <- data.frame(id = id, response = response)
```

```{r echo=FALSE}
y_list <- split(response, df_simu$id)
plot(x=c(0,1), y = c(-200, 200), type="n", xlab="time", ylab = "response")
for (i in 1:873){
  lines(time_rang, y_list[[i]], type = "l", col = i)
}
```

```{r include=FALSE}
fit_genetic_fmm <- function(formula, data, A, phi)
  {
  #'This function uses the lme4 package to fit a linear mixed-effect model to genetic data, 
  #'with a specified additive genetic relationship matrix A.
  #'In this particular format, we fit both fixed effects and random effects using the same
  #'basis functions (principal components obtained from running FPCA).
  #'
  #'@param fromula a two-sided linear formula object describing both the fixed-effects
  #'and random-effects of the model (as the same form used in lmer).
  #'@param data an data frame containing the variables named in formula.
  #'@param A a sparse matrix: an additive genetic relationship matrix 
  #'which models the genetic relationship in the dataset.
  #'@param phi functional basis: a matrix where each column represents a basis element.
  #'@return returns a fitted mixed-effect model
  
  # Random effect parameterisation
  require(lme4)
  require(Matrix)
  
  L <- as(t(chol(A)), "dgCMatrix") # cholesky decomposition of A
  p <- dim(phi)[2] # number of elements of the functional basis
  I_p <- as(diag(p), "dgCMatrix")
  M <- kronecker(L, I_p) # used to update the genetic design matrix Z_E = ZM
  
  # Fit mixed-effect model
  
  ## define the mixed-model formula
  fmmParsedForm <- lFormula(formula, data=data)
  
  ### Compute the random-effect matrix
  Z_pre <- t(fmmParsedForm$reTrms$Zt)
  ZE <- Z_pre[,1:dim(M)[1]] # environmental random-effect matrix
  ZG <- Z_pre[,1:dim(M)[1]] %*% M # update the genetic-random effect matrix
  Z <- cbind(ZG, ZE) # the updated random effect design matrix
  
  ### Modularisation
  fmmParsedForm$reTrms$Zt <- t(Z) # Update Z in the reTrms term
  fmmDevFun <- do.call(mkLmerDevfun,fmmParsedForm) # update the objective function
  fmmOpitimize <- optimizeLmer(devfun=fmmDevFun)# update the optimisation module
  
  ### returns the mixed-effect model
  fmm <- mkMerMod(rho=environment(fmmDevFun),opt=fmmOpitimize, reTrms=fmmParsedForm$reTrms, fr=fmmParsedForm$fr)

  return(fmm)
}
```

## Fit simulated data
```{r}
## Data smoothing
timefine <- seq(0,1,length=25) # slightly dense time grid
y_hat <- matrix(0, 25, 873)
lambda <- rep(0, 873)
for (i in 1:873){
  ss <- smooth.spline(time_rang, y_list[[i]], cv = FALSE)
  y_hat[,i] <- predict(ss, timefine)$y
  lambda[i] <- ss$lambda
}

matplot(timefine, y_hat, col = 1:873, type= "l") ### smoothed curves
```

```{r}
## FPCA
fpcaobj <- prcomp(x=t(y_hat), retx = TRUE, center = TRUE, rank. = 3)
pcs <- fpcaobj$rotation # eigen vectors as basis functions for moedel-fitting

pcs[,1] %*% pcs[,2]
pcs[,1] %*% pcs[,3]
pcs[,2] %*% pcs[,3]

## Combine the smoothed data and basis functions to a dataframe
subjectID <- rep(unique(df_simu$id), each=25)
response_test <- c(y_hat)
basis1 <- rep(pcs[,1], times = 873)
basis2 <- rep(pcs[,2], times = 873)
basis3 <- rep(pcs[,3], times = 873)

df_test <- data.frame(id = subjectID, y= response_test, phi1 = basis1, phi2 = basis2, phi3 = basis3) 

## Fit FMEM
fform <- y ~ -1 + df_test$phi1 + df_test$phi2 + df_test$phi3 + 
  (-1 + df_test$phi1 + df_test$phi2 + df_test$phi3 | df_test$id) + 
  (-1 + df_test$phi1 + df_test$phi2 + df_test$phi3 | df_test$id)

system.time(
 ft <-  fit_genetic_fmm(fform, df_test, A, pcs)
) # user   system   elapsed

summary(ft)
```

```{r}
# Extract covariance function
vc <- VarCorr(ft)
CG <- vc[["df_test.id"]] ## genetic covariance
CE <- vc[["df_test.id.1"]] ## environmental covariance


### Convert to genetic covariance function
CG_fun <- pcs %*% CG %*% t(pcs)
### environmental covariance function
CE_fun <- pcs %*% CE %*% t(pcs)
### Phenotypic covariance function
P_fun <- CG_fun + CE_fun

# Plot the genetic covariance function
fig_RR1 <- plot_ly(x = timefine, y = timefine, z = ~CG_fun, 
                   type = "surface", showscale = FALSE) %>% 
  layout(title = "Genetic Variance Function", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))

# Plot the environmental covariance function
fig_RR2 <- plot_ly(x = timefine, y = timefine, z = ~CE_fun, 
                   type = "surface", showscale = FALSE) %>% 
  layout(title = "Environment Variance Function", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))

# Plot the phenotypic covariance function
fig_RR3 <- plot_ly(x = timefine, y = timefine, z = ~P_fun, 
                   type = "surface", showscale = FALSE) %>% 
  layout(title = "Phenotypic Variance Function", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))

# Display each plot separately

fig_RR1
fig_RR2
fig_RR3

```

### Covariance estimation when 4 PCs used as basis functions
```{r include=FALSE}
## FPCA
fpcaobj <- prcomp(x=t(y_hat), retx = TRUE, center = TRUE, rank. = 4) # use 4 PCs as basis
pcs <- fpcaobj$rotation # eigen vectors as basis functions for moedel-fitting

## Combine the smoothed data and basis functions to a dataframe
subjectID <- rep(unique(df_simu$id), each=25)
response_test <- c(y_hat)
basis1 <- rep(pcs[,1], times = 873)
basis2 <- rep(pcs[,2], times = 873)
basis3 <- rep(pcs[,3], times = 873)
basis4 <- rep(pcs[,4], times = 873)

df_test <- data.frame(id = subjectID, y= response_test, phi1 = basis1, phi2 = basis2, phi3 = basis3, phi4 = basis4) 

## Fit FMEM
fform <- y ~ -1 + df_test$phi1 + df_test$phi2 + df_test$phi3 + df_test$phi4 + 
  (-1 + df_test$phi1 + df_test$phi2 + df_test$phi3 + df_test$phi4 | df_test$id) + 
  (-1 + df_test$phi1 + df_test$phi2 + df_test$phi3 + df_test$phi4 | df_test$id)

system.time(
 ft <-  fit_genetic_fmm(fform, df_test, A, pcs)
) # user   system   elapsed

summary(ft)
```

```{r echo=FALSE}
# Extract covariance function
vc <- VarCorr(ft)
CG <- vc[["df_test.id"]] ## genetic covariance
CE <- vc[["df_test.id.1"]] ## environmental covariance


### Convert to genetic covariance function
CG_fun <- pcs %*% CG %*% t(pcs)
### environmental covariance function
CE_fun <- pcs %*% CE %*% t(pcs)
### Phenotypic covariance function
P_fun <- CG_fun + CE_fun

# Plot the genetic covariance function
fig_RR1 <- plot_ly(x = timefine, y = timefine, z = ~CG_fun, 
                   type = "surface", showscale = FALSE) %>% 
  layout(title = "Genetic Variance Function", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))

# Plot the environmental covariance function
fig_RR2 <- plot_ly(x = timefine, y = timefine, z = ~CE_fun, 
                   type = "surface", showscale = FALSE) %>% 
  layout(title = "Environment Variance Function", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))

# Plot the phenotypic covariance function
fig_RR3 <- plot_ly(x = timefine, y = timefine, z = ~P_fun, 
                   type = "surface", showscale = FALSE) %>% 
  layout(title = "Phenotypic Variance Function", 
         scene = list(zaxis = list(title=""),
                      xaxis = list(title = "time"),
                      yaxis = list(title = "time")))

# Display each plot separately

fig_RR1
fig_RR2
fig_RR3
```